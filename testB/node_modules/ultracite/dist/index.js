#!/usr/bin/env node
var Z=Object.defineProperty;var Ze=Object.getOwnPropertyDescriptor;var et=Object.getOwnPropertyNames;var tt=Object.prototype.hasOwnProperty;var ee=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,o)=>(typeof require<"u"?require:e)[o]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')}),we=t=>e=>{var o=t[e];if(o)return o();throw new Error("Module not found in bundle: "+e)};var D=(t,e)=>()=>(t&&(e=t(t=0)),e);var te=(t,e)=>{for(var o in e)Z(t,o,{get:e[o],enumerable:!0})},ot=(t,e,o,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of et(e))!tt.call(t,s)&&s!==o&&Z(t,s,{get:()=>e[s],enumerable:!(n=Ze(e,s))||n.enumerable});return t};var oe=t=>ot(Z({},"__esModule",{value:!0}),t);import{access as nt,readFile as ke,writeFile as it}from"fs/promises";import{parse as at}from"jsonc-parser";var r,g,be,k,rt,ct,L,f=D(()=>{"use strict";r=async t=>{try{return await nt(t),!0}catch{return!1}},g=async()=>{if(await r("pnpm-workspace.yaml"))return!0;try{let t=at(await ke("package.json","utf-8"));return t?!!t.workspaces||!!t.workspace:!1}catch{return!1}},be=`
888     888 888    88888888888 8888888b.         d8888  .d8888b. 8888888 88888888888 8888888888 
888     888 888        888     888   Y88b       d88888 d88P  Y88b  888       888     888        
888     888 888        888     888    888      d88P888 888    888  888       888     888        
888     888 888        888     888   d88P     d88P 888 888         888       888     8888888    
888     888 888        888     8888888P"     d88P  888 888         888       888     888        
888     888 888        888     888 T88b     d88P   888 888    888  888       888     888        
Y88b. .d88P 888        888     888  T88b   d8888888888 Y88b  d88P  888       888     888        
 "Y88888P"  88888888   888     888   T88b d88P     888  "Y8888P" 8888888     888     8888888888
`,k=async({dependencies:t,devDependencies:e,scripts:o})=>{let n=await ke("package.json","utf8"),s=JSON.parse(n),i={...s};(s.devDependencies||e)&&(i.devDependencies={...s.devDependencies,...e}),(s.dependencies||t)&&(i.dependencies={...s.dependencies,...t}),(s.scripts||o)&&(i.scripts={...s.scripts,...o}),await it("package.json",JSON.stringify(i,null,2))},rt=/[ $(){}[\]&|;<>!"'`*?#~]/,ct=/'/g,L=t=>t.map(e=>rt.test(e)?`'${e.replace(ct,"'\\''")}' `:e)});var ze={};te(ze,{husky:()=>x});import{execSync as Yt}from"child_process";import{mkdir as Kt,readFile as Xt,writeFile as Je}from"fs/promises";import{addDevDependency as Qt,dlxCommand as de}from"nypm";var Le,Y,x,me=D(()=>{"use strict";f();Le=t=>`#!/bin/sh
# Exit on any error
set -e

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications
STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
PARTIALLY_STAGED=$(git diff --name-only)

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
git stash push --quiet --keep-index --message "pre-commit-stash" || true
STASHED=$?

# Run formatter on the staged files
${t}
FORMAT_EXIT_CODE=$?

# Restore working directory state
if [ $STASHED -eq 0 ]; then
  # Re-stage the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
  
  # Restore unstaged changes
  git stash pop --quiet || true
  
  # Restore partial staging if files were partially staged
  if [ -n "$PARTIALLY_STAGED" ]; then
    for file in $PARTIALLY_STAGED; do
      if [ -f "$file" ] && echo "$STAGED_FILES" | grep -q "^$file$"; then
        # File was partially staged - need to unstage the unstaged parts
        git restore --staged "$file" 2>/dev/null || true
        git add -p "$file" < /dev/null 2>/dev/null || git add "$file"
      fi
    done
  fi
else
  # No stash was created, just re-add the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
fi

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "\u2728 Files formatted by Ultracite"
fi

exit $FORMAT_EXIT_CODE
`,Y="./.husky/pre-commit",x={exists:()=>r(Y),install:async t=>{await Qt("husky",{packageManager:t,workspace:await g()}),await k({scripts:{prepare:"husky"}})},init:t=>{let e=de(t,"husky",{args:["init"]});try{Yt(e,{stdio:"inherit"})}catch{}},create:async t=>{await Kt(".husky",{recursive:!0});let e=de(t,"ultracite",{args:["fix"],short:t==="npm"}),o=Le(e);await Je(Y,o)},update:async t=>{let e=await Xt(Y,"utf-8"),o=de(t,"ultracite",{args:["fix"],short:t==="npm"}),n=Le(o);await Je(Y,`${e}
${n}`)}}});var Ge={};te(Ge,{lefthook:()=>A});import{execSync as Zt}from"child_process";import{readFile as eo,writeFile as _}from"fs/promises";import{addDevDependency as to,dlxCommand as We}from"nypm";var oo,so,Be,v,He,A,pe=D(()=>{"use strict";f();oo=/(pre-commit:\s*\n\s*jobs:\s*\n)/,so=/(pre-commit:\s*\n)/,Be=t=>We(t,"ultracite",{args:["fix"],short:t==="npm"}),v="./lefthook.yml",He=t=>`pre-commit:
  jobs:
    - run: ${Be(t)}
      glob: 
        - "*.js"
        - "*.jsx"
        - "*.ts"
        - "*.tsx"
        - "*.json"
        - "*.jsonc"
        - "*.css"
      stage_fixed: true
`,A={exists:()=>r(v),install:async t=>{await to("lefthook",{packageManager:t,workspace:await g()});let e=We(t,"lefthook",{args:["install"],short:t==="npm"});Zt(e)},create:async t=>{let e=He(t);await _(v,e)},update:async t=>{let e=await eo(v,"utf-8"),o=Be(t),n=He(t);if(e.includes(o))return;if(e.startsWith("# EXAMPLE USAGE:")){await _(v,n);return}if(e.includes("pre-commit:"))if(e.includes("jobs:")){let i=`    - run: ${o}
      glob: 
        - "*.js"
        - "*.jsx"
        - "*.ts"
        - "*.tsx"
        - "*.json"
        - "*.jsonc"
        - "*.css"
      stage_fixed: true`,a=e.replace(oo,`$1${i}
`);await _(v,a)}else{let i=`  jobs:
    - run: ${o}
      glob: 
        - "*.js"
        - "*.jsx"
        - "*.ts"
        - "*.tsx"
        - "*.json"
        - "*.jsonc"
        - "*.css"
      stage_fixed: true`,a=e.replace(so,`$1${i}
`);await _(v,a)}else await _(v,`${e}
${n}`)}}});var no,fe=D(()=>{no=we({"./husky.ts":()=>(me(),oe(ze)),"./lefthook.ts":()=>(pe(),oe(Ge)),"./lint-staged.ts":()=>(ue(),oe(qe))})});var qe={};te(qe,{lintStaged:()=>E});import{readFile as K,writeFile as C}from"fs/promises";import{pathToFileURL as io}from"url";import J from"deepmerge";import{parse as he}from"jsonc-parser";import{addDevDependency as ao,dlxCommand as ro}from"nypm";var h,Ve,co,lo,mo,po,fo,uo,go,ho,yo,ge,wo,E,ue=D(()=>{"use strict";f();fe();h=t=>({"*.{js,jsx,ts,tsx,json,jsonc,css,scss,md,mdx}":[ro(t,"ultracite",{args:["fix"],short:t==="npm"})]}),Ve=["./package.json","./.lintstagedrc.json","./.lintstagedrc.js","./.lintstagedrc.cjs","./.lintstagedrc.mjs","./lint-staged.config.js","./lint-staged.config.cjs","./lint-staged.config.mjs","./.lintstagedrc.yaml","./.lintstagedrc.yml","./.lintstagedrc"],co=(t,e,o,n)=>{let s=t.trim();if(s.includes(":")&&!s.startsWith("-")){o&&n.length>0&&(e[o]=n);let[i,...a]=s.split(":"),l=a.join(":").trim(),m=i.trim().replace(/['"]/g,"");return l&&l!==""?(l.startsWith("[")&&l.endsWith("]")?e[m]=l.slice(1,-1).split(",").map(P=>P.trim().replace(/['"]/g,"")):e[m]=l.replace(/['"]/g,""),{newCurrentKey:null,newCurrentArray:[]}):{newCurrentKey:m,newCurrentArray:[]}}if(s.startsWith("-")&&o){let i=[...n,s.slice(1).trim().replace(/['"]/g,"")];return{newCurrentKey:o,newCurrentArray:i}}return{newCurrentKey:o,newCurrentArray:n}},lo=t=>{let e=t.split(`
`).filter(i=>i.trim()&&!i.trim().startsWith("#")),o={},n=null,s=[];for(let i of e){let a=co(i,o,n,s);n=a.newCurrentKey,s=a.newCurrentArray}return n&&s.length>0&&(o[n]=s),o},mo=t=>{let e="";for(let[o,n]of Object.entries(t))if(Array.isArray(n)){e+=`${o}:
`;for(let s of n)e+=`  - '${s}'
`}else e+=`${o}: '${n}'
`;return e},po=async()=>{try{let t=he(await K("./package.json","utf-8"));return t?t.type==="module":!1}catch{return!1}},fo=async t=>{let e=he(await K("./package.json","utf-8"));e&&(e["lint-staged"]?e["lint-staged"]=J(e["lint-staged"],h(t)):e["lint-staged"]=h(t),await C("./package.json",JSON.stringify(e,null,2)))},uo=async(t,e)=>{let o=await K(t,"utf-8"),n=he(o);if(!n)return;let s=J(n,h(e));await C(t,JSON.stringify(s,null,2))},go=async(t,e)=>{let o=await K(t,"utf-8"),n=lo(o);if(!n)return;let s=J(n,h(e));await C(t,mo(s))},ho=async(t,e)=>{let s=(await import(io(t).href)).default||{},i=J(s,h(e)),a=`export default ${JSON.stringify(i,null,2)};
`;await C(t,a)},yo=async(t,e)=>{delete ee.cache[ee.resolve(`./${t}`)];let o=no(`./${t}`),n=J(o,h(e)),s=`module.exports = ${JSON.stringify(n,null,2)};
`;await C(t,s)},ge=async t=>{await C(".lintstagedrc.json",JSON.stringify(h(t),null,2))},wo=async(t,e)=>{if(t==="./package.json"){await fo(e);return}if(t.endsWith(".json")||t==="./.lintstagedrc"){await uo(t,e);return}if(t.endsWith(".yaml")||t.endsWith(".yml")){await go(t,e);return}let o=await po();if(t.endsWith(".mjs")||t.endsWith(".js")&&o){try{await ho(t,e)}catch{await ge(e)}return}if(t.endsWith(".cjs")||t.endsWith(".js")&&!o)try{await yo(t,e)}catch{await ge(e)}},E={exists:async()=>{for(let t of Ve)if(await r(t))return!0;return!1},install:async t=>{await ao("lint-staged",{packageManager:t,workspace:await g()})},create:async t=>{await C(".lintstagedrc.json",JSON.stringify(h(t),null,2))},update:async t=>{let e=null;for(let o of Ve)if(await r(o)){e=o;break}if(!e){await ge(t);return}await wo(e,t)}}});import{initTRPC as Lo}from"@trpc/server";import{createCli as zo}from"trpc-cli";import c from"zod";var w={name:"ultracite",description:"The AI-ready formatter that helps you write and generate code faster.",version:"6.3.0",type:"module",bin:{ultracite:"dist/index.js"},files:["config","dist","README.md"],scripts:{build:"tsup",test:"bun test","test:coverage":"bun test --coverage"},exports:{"./*":"./config/*/biome.jsonc"},author:"Hayden Bleasel <hello@haydenbleasel.com>",bugs:{url:"https://github.com/haydenbleasel/ultracite/issues"},homepage:"https://www.ultracite.ai/",keywords:["ultracite","biome","linter","formatter","fixer"],license:"MIT",publishConfig:{access:"public",registry:"https://registry.npmjs.org/"},repository:{type:"git",url:"git+https://github.com/haydenbleasel/ultracite.git"},devDependencies:{"@biomejs/biome":"2.3.4","@types/node":"^24.10.0",tsup:"^8.5.0",turbo:"^2.6.0"},dependencies:{"@clack/prompts":"^0.11.0","@trpc/server":"^11.7.1",deepmerge:"^4.3.1",glob:"^11.0.3","jsonc-parser":"^3.3.1",nypm:"^0.6.2","trpc-cli":"^0.12.0",zod:"^4.1.12"},packageManager:"bun@1.3.1"};f();import{spawnSync as lt}from"child_process";import xe from"process";var se=t=>{let e=t?.[0]||[],o=t?.[1]["diagnostic-level"],n=["npx","@biomejs/biome","check","--no-errors-on-unmatched"];o&&n.push(`--diagnostic-level=${o}`),e.length>0?n.push(...L(e)):n.push("./");let s=n.join(" "),i=lt(s,{stdio:"inherit",shell:!0});i.error&&(console.error("Failed to run Ultracite:",i.error.message),xe.exit(1)),i.status!==0&&xe.exit(i.status??1)};import{spawnSync as jt}from"child_process";import{existsSync as T}from"fs";import{readFile as Ae}from"fs/promises";import{join as M}from"path";import{parse as Pt}from"jsonc-parser";f();import{readFile as ve,unlink as dt,writeFile as mt}from"fs/promises";import{parse as Ce}from"jsonc-parser";import{removeDependency as pt}from"nypm";var z=[".eslintrc",".eslintrc.js",".eslintrc.json",".eslintrc.yml",".eslintrc.yaml",".eslintrc.config.js","eslint.config.js","eslint.config.mjs","eslint.config.cjs",".eslintignore"],je=async()=>{try{let t=await ve("package.json","utf-8"),e=Ce(t);if(!e||typeof e!="object")return[];let o=e.dependencies||{},n=e.devDependencies||{},s={...o,...n};return Object.keys(s).filter(i=>i.includes("eslint"))}catch{return[]}},ft=async(t,e)=>{if(e.length!==0)try{for(let o of e)await pt(o,{packageManager:t})}catch(o){console.warn(o)}},ut=async()=>{let t=[];for(let e of z)if(await r(e))try{await dt(e),t.push(e)}catch(o){console.warn(o)}return t},gt=async()=>{let t="./.vscode/settings.json";if(!await r(t))return!1;try{let e=await ve(t,"utf-8"),o=Ce(e);if(!o||typeof o!="object")return!1;let n=!1,s={...o},i=["eslint.enable","eslint.format.enable","eslint.validate","eslint.workingDirectories","eslint.codeAction.showDocumentation","eslint.run","eslint.autoFixOnSave","eslint.quiet","eslint.packageManager","eslint.options","eslint.trace.server"];for(let a of i)a in s&&(delete s[a],n=!0);if("editor.codeActionsOnSave"in s){let a=s["editor.codeActionsOnSave"];if(a&&typeof a=="object"){let l=["source.fixAll.eslint","source.organizeImports.eslint"];for(let m of l)m in a&&(delete a[m],n=!0);Object.keys(a).length===0&&(s["editor.codeActionsOnSave"]=void 0)}}return n?(await mt(t,JSON.stringify(s,null,2)),!0):!1}catch(e){return console.warn(e),!1}},ht=async()=>{if((await je()).length>0)return!0;for(let e of z)if(await r(e))return!0;return!1},ne={hasEsLint:ht,remove:async t=>{let e=await je();await ft(t,e);let o=await ut(),n=await gt();return{packagesRemoved:e,filesRemoved:o,vsCodeCleaned:n}}};f();import{readFile as Pe,unlink as yt,writeFile as wt}from"fs/promises";import{parse as Se}from"jsonc-parser";import{removeDependency as kt}from"nypm";var H=[".prettierrc",".prettierrc.js",".prettierrc.json",".prettierrc.yml",".prettierrc.yaml",".prettierrc.config.js","prettier.config.js","prettier.config.mjs",".prettierignore"],Re=async()=>{try{let t=await Pe("package.json","utf-8"),e=Se(t);if(!e||typeof e!="object")return[];let o=e.dependencies||{},n=e.devDependencies||{},s={...o,...n};return Object.keys(s).filter(i=>i.includes("prettier"))}catch{return[]}},bt=async(t,e)=>{if(e.length!==0)try{for(let o of e)await kt(o,{packageManager:t})}catch(o){console.warn(o)}},xt=async()=>{let t=[];for(let e of H)if(await r(e))try{await yt(e),t.push(e)}catch(o){console.warn(o)}return t},vt=async()=>{let t="./.vscode/settings.json";if(!await r(t))return!1;try{let e=await Pe(t,"utf-8"),o=Se(e);if(!o||typeof o!="object")return!1;let n=!1,s={...o},i=["editor.defaultFormatter","prettier.enable","prettier.requireConfig","prettier.configPath","prettier.printWidth","prettier.tabWidth","prettier.useTabs","prettier.semi","prettier.singleQuote","prettier.quoteProps","prettier.trailingComma","prettier.bracketSpacing","prettier.arrowParens","prettier.endOfLine"];for(let l of i)l in s&&(l==="editor.defaultFormatter"&&s[l]==="esbenp.prettier-vscode"||l!=="editor.defaultFormatter")&&(delete s[l],n=!0);let a=Object.keys(s).filter(l=>l.startsWith("[")&&l.includes("javascript"));for(let l of a){let m=s[l];m&&typeof m=="object"&&"editor.defaultFormatter"in m&&m["editor.defaultFormatter"]==="esbenp.prettier-vscode"&&(delete m["editor.defaultFormatter"],n=!0,Object.keys(m).length===0&&delete s[l])}return n?(await wt(t,JSON.stringify(s,null,2)),!0):!1}catch(e){return console.warn(e),!1}},Ct=async()=>{if((await Re()).length>0)return!0;for(let e of H)if(await r(e))return!0;return!1},ie={hasPrettier:Ct,remove:async t=>{let e=await Re();await bt(t,e);let o=await xt(),n=await vt();return{packagesRemoved:e,filesRemoved:o,vsCodeCleaned:n}}};var St=()=>{let t=jt("npx @biomejs/biome --version",{shell:!0,encoding:"utf-8"});return t.status===0&&t.stdout?{name:"Biome installation",status:"pass",message:`Biome is installed (${t.stdout.trim()})`}:{name:"Biome installation",status:"fail",message:"Biome is not installed or not accessible"}},Rt=async()=>{let t=M(process.cwd(),"biome.json"),e=M(process.cwd(),"biome.jsonc"),o=null;if(T(t)?o=t:T(e)&&(o=e),!o)return{name:"Biome configuration",status:"fail",message:"No biome.json or biome.jsonc file found"};try{let n=await Ae(o,"utf-8"),s=Pt(n);return Array.isArray(s?.extends)&&s.extends.includes("ultracite/core")?{name:"Biome configuration",status:"pass",message:"biome.json(c) extends ultracite/core"}:{name:"Biome configuration",status:"warn",message:"biome.json(c) exists but doesn't extend ultracite/core"}}catch{return{name:"Biome configuration",status:"fail",message:"Could not parse biome.json(c) file"}}},At=async()=>{let t=M(process.cwd(),"package.json");if(!T(t))return{name:"Ultracite dependency",status:"warn",message:"No package.json found"};try{let e=JSON.parse(await Ae(t,"utf-8")),o=e.dependencies?.ultracite||e.devDependencies?.ultracite||e.peerDependencies?.ultracite;return o?{name:"Ultracite dependency",status:"pass",message:`Ultracite is in package.json (${o})`}:{name:"Ultracite dependency",status:"warn",message:"Ultracite not found in package.json dependencies"}}catch{return{name:"Ultracite dependency",status:"warn",message:"Could not parse package.json"}}},Et=()=>{let t=H.some(o=>T(M(process.cwd(),o))),e=z.some(o=>T(M(process.cwd(),o)));if(t||e){let o=[];return t&&o.push("Prettier"),e&&o.push("ESLint"),{name:"Conflicting tools",status:"warn",message:`Found potentially conflicting tools: ${o.join(", ")}`}}return{name:"Conflicting tools",status:"pass",message:"No conflicting formatting/linting tools found"}},Ee=async()=>{let t=[];console.log(`\u{1FA7A} Running Ultracite doctor...
`),t.push(St()),t.push(await Rt()),t.push(await At()),t.push(Et());let e=t.filter(s=>s.status==="pass").length,o=t.filter(s=>s.status==="fail").length,n=t.filter(s=>s.status==="warn").length;for(let s of t){let i;s.status==="pass"?i="\u2705":s.status==="fail"?i="\u274C":i="\u26A0\uFE0F",console.log(`${i} ${s.name}: ${s.message}`)}console.log(`
\u{1F4CA} Summary:`),console.log(`   ${e} passed, ${n} warnings, ${o} failed`),o>0&&(console.log(`
\u{1F4A1} To fix issues, run: npx ultracite init`),process.exit(1)),n>0?console.log(`
\u{1F4A1} Some optional improvements available. Run 'npx ultracite init' to configure.`):console.log(`
\u2728 Everything looks good!`)};f();import{spawnSync as Ft}from"child_process";import Fe from"process";var ae=(t,e={})=>{let o=["npx","@biomejs/biome","check","--write","--no-errors-on-unmatched"];e.unsafe&&o.push("--unsafe"),t.length>0?o.push(...L(t)):o.push("./");let n=o.join(" "),s=Ft(n,{stdio:"inherit",shell:!0});s.error&&(console.error("Failed to run Ultracite:",s.error.message),Fe.exit(1)),s.status!==0&&Fe.exit(s.status??1)};import{packageManagers as $t}from"nypm";var b={packageManagers:$t.map(t=>t.name),editorConfigs:["vscode","zed"],agents:["vscode-copilot","cursor","windsurf","zed","claude","codex","kiro","cline","amp","aider","firebase-studio","open-hands","gemini-cli","junie","augmentcode","kilo-code","goose","roo-code","warp"],integrations:["husky","lefthook","lint-staged"],hooks:["cursor","claude"],frameworks:["react","next","solid","vue","svelte","qwik","remix","angular","astro"],migrations:["eslint","prettier"]};import y from"process";import{cancel as F,intro as So,isCancel as $,log as X,multiselect as N,spinner as u}from"@clack/prompts";import{addDevDependency as Ro,detectPackageManager as Ao}from"nypm";import{mkdir as Nt,readFile as Ot,writeFile as W}from"fs/promises";import{dirname as Dt}from"path";var $e={"vscode-copilot":{path:"./.github/copilot-instructions.md",header:`---
applyTo: "**/*.{ts,tsx,js,jsx}"
---`,appendMode:!0},cursor:{path:"./.cursor/rules/ultracite.mdc",header:`---
description: Ultracite Rules - AI-Ready Formatter and Linter
globs: "**/*.{ts,tsx,js,jsx,json,jsonc,html,vue,svelte,astro,css,yaml,yml,graphql,gql,md,mdx,grit}"
alwaysApply: false
---`},windsurf:{path:"./.windsurf/rules/ultracite.md"},zed:{path:"./.rules",appendMode:!0},claude:{path:"./.claude/CLAUDE.md",appendMode:!0},codex:{path:"./AGENTS.md",appendMode:!0},kiro:{path:"./.kiro/steering/ultracite.md"},cline:{path:"./.clinerules",appendMode:!0},amp:{path:"./AGENT.md",appendMode:!0},aider:{path:"./ultracite.md"},"firebase-studio":{path:"./.idx/airules.md",appendMode:!0},"open-hands":{path:"./.openhands/microagents/repo.md",appendMode:!0},"gemini-cli":{path:"./GEMINI.md",appendMode:!0},junie:{path:"./.junie/guidelines.md",appendMode:!0},augmentcode:{path:"./.augment/rules/ultracite.md"},"kilo-code":{path:"./.kilocode/rules/ultracite.md"},goose:{path:"./.goosehints",appendMode:!0},"roo-code":{path:"./.roo/rules/ultracite.md",appendMode:!0},warp:{path:"./WARP.md",appendMode:!0}},Ne={cursor:{path:"./.cursor/hooks.json",command:"npx ultracite fix"},claude:{path:"./.claude/settings.json",command:"npx ultracite fix"}};f();var U=`# Ultracite Code Standards

This project uses **Ultracite**, a zero-config Biome preset that enforces strict code quality standards through automated formatting and linting.

## Quick Reference

- **Format code**: \`npx ultracite fix\`
- **Check for issues**: \`npx ultracite check\`
- **Diagnose setup**: \`npx ultracite doctor\`

Biome (the underlying engine) provides extremely fast Rust-based linting and formatting. Most issues are automatically fixable.

---

## Core Principles

Write code that is **accessible, performant, type-safe, and maintainable**. Focus on clarity and explicit intent over brevity.

### Type Safety & Explicitness

- Use explicit types for function parameters and return values when they enhance clarity
- Prefer \`unknown\` over \`any\` when the type is genuinely unknown
- Use const assertions (\`as const\`) for immutable values and literal types
- Leverage TypeScript's type narrowing instead of type assertions
- Use meaningful variable names instead of magic numbers - extract constants with descriptive names

### Modern JavaScript/TypeScript

- Use arrow functions for callbacks and short functions
- Prefer \`for...of\` loops over \`.forEach()\` and indexed \`for\` loops
- Use optional chaining (\`?.\`) and nullish coalescing (\`??\`) for safer property access
- Prefer template literals over string concatenation
- Use destructuring for object and array assignments
- Use \`const\` by default, \`let\` only when reassignment is needed, never \`var\`

### Async & Promises

- Always \`await\` promises in async functions - don't forget to use the return value
- Use \`async/await\` syntax instead of promise chains for better readability
- Handle errors appropriately in async code with try-catch blocks
- Don't use async functions as Promise executors

### React & JSX

- Use function components over class components
- Call hooks at the top level only, never conditionally
- Specify all dependencies in hook dependency arrays correctly
- Use the \`key\` prop for elements in iterables (prefer unique IDs over array indices)
- Nest children between opening and closing tags instead of passing as props
- Don't define components inside other components
- Use semantic HTML and ARIA attributes for accessibility:
  - Provide meaningful alt text for images
  - Use proper heading hierarchy
  - Add labels for form inputs
  - Include keyboard event handlers alongside mouse events
  - Use semantic elements (\`<button>\`, \`<nav>\`, etc.) instead of divs with roles

### Error Handling & Debugging

- Remove \`console.log\`, \`debugger\`, and \`alert\` statements from production code
- Throw \`Error\` objects with descriptive messages, not strings or other values
- Use \`try-catch\` blocks meaningfully - don't catch errors just to rethrow them
- Prefer early returns over nested conditionals for error cases

### Code Organization

- Keep functions focused and under reasonable cognitive complexity limits
- Extract complex conditions into well-named boolean variables
- Use early returns to reduce nesting
- Prefer simple conditionals over nested ternary operators
- Group related code together and separate concerns

### Security

- Add \`rel="noopener"\` when using \`target="_blank"\` on links
- Avoid \`dangerouslySetInnerHTML\` unless absolutely necessary
- Don't use \`eval()\` or assign directly to \`document.cookie\`
- Validate and sanitize user input

### Performance

- Avoid spread syntax in accumulators within loops
- Use top-level regex literals instead of creating them in loops
- Prefer specific imports over namespace imports
- Avoid barrel files (index files that re-export everything)
- Use proper image components (e.g., Next.js \`<Image>\`) over \`<img>\` tags

### Framework-Specific Guidance

**Next.js:**
- Use Next.js \`<Image>\` component for images
- Use \`next/head\` or App Router metadata API for head elements
- Use Server Components for async data fetching instead of async Client Components

**React 19+:**
- Use ref as a prop instead of \`React.forwardRef\`

**Solid/Svelte/Vue/Qwik:**
- Use \`class\` and \`for\` attributes (not \`className\` or \`htmlFor\`)

---

## Testing

- Write assertions inside \`it()\` or \`test()\` blocks
- Avoid done callbacks in async tests - use async/await instead
- Don't use \`.only\` or \`.skip\` in committed code
- Keep test suites reasonably flat - avoid excessive \`describe\` nesting

## When Biome Can't Help

Biome's linter will catch most issues automatically. Focus your attention on:

1. **Business logic correctness** - Biome can't validate your algorithms
2. **Meaningful naming** - Use descriptive names for functions, variables, and types
3. **Architecture decisions** - Component structure, data flow, and API design
4. **Edge cases** - Handle boundary conditions and error states
5. **User experience** - Accessibility, performance, and usability considerations
6. **Documentation** - Add comments for complex logic, but prefer self-documenting code

---

Most formatting and common issues are automatically fixed by Biome. Run \`npx ultracite fix\` before committing to ensure compliance.
`;var Oe=t=>{let e=$e[t],o=e.header?`${e.header}

${U}`:U,n=async()=>{let s=Dt(e.path);if(s!=="."){let i=s.startsWith("./")?s.slice(2):s;await Nt(i,{recursive:!0})}};return{exists:()=>r(e.path),create:async()=>{await n(),await W(e.path,o)},update:async()=>{if(await n(),e.appendMode){if(!await r(e.path)){await W(e.path,o);return}let s=await Ot(e.path,"utf-8");if(s.includes(U.trim()))return;await W(e.path,`${s}

${U}`)}else await W(e.path,o)}}};f();import{readFile as Tt,writeFile as De}from"fs/promises";import Mt from"deepmerge";import{parse as Ut}from"jsonc-parser";var Te={$schema:"./node_modules/@biomejs/biome/configuration_schema.json",extends:["ultracite/core"]},re=async()=>await r("./biome.json")?"./biome.json":"./biome.jsonc",B={exists:async()=>{let t=await re();return r(t)},create:async t=>{let e=await re(),o=["ultracite/core"];if(t?.frameworks&&t.frameworks.length>0)for(let s of t.frameworks)o.push(`ultracite/${s}`);let n={...Te,extends:o};return De(e,JSON.stringify(n,null,2))},update:async t=>{let e=await re(),o=await Tt(e,"utf-8"),s=Ut(o)||{},a=[...s.extends&&Array.isArray(s.extends)?s.extends:[]];if(a.includes("ultracite/core")||a.push("ultracite/core"),t?.frameworks&&t.frameworks.length>0)for(let P of t.frameworks){let O=`ultracite/${P}`;a.includes(O)||a.push(O)}s.extends=a;let l={$schema:Te.$schema},m=Mt(s,l);await De(e,JSON.stringify(m,null,2))}};import{mkdir as It,readFile as Me,writeFile as R}from"fs/promises";import{dirname as _t}from"path";f();var Ue=t=>{let e=Ne[t],o=async()=>{let n=_t(e.path);if(n!=="."){let s=n.startsWith("./")?n.slice(2):n;await It(s,{recursive:!0})}};return{exists:()=>r(e.path),create:async()=>{await o(),t==="cursor"?await R(e.path,JSON.stringify({version:1,hooks:{afterFileEdit:[{command:e.command}]}},null,2)):t==="claude"&&await R(e.path,JSON.stringify({hooks:{PostToolUse:[{matcher:"Edit|Write",hooks:[{type:"command",command:e.command}]}]}},null,2))},update:async()=>{if(await o(),t==="cursor"){if(!await r(e.path)){await R(e.path,JSON.stringify({version:1,hooks:{afterFileEdit:[{command:e.command}]}},null,2));return}let n=await Me(e.path,"utf-8"),s=JSON.parse(n);s.hooks.afterFileEdit.some(a=>a.command.includes("ultracite"))||(s.hooks.afterFileEdit.push({command:e.command}),await R(e.path,JSON.stringify(s,null,2)))}else if(t==="claude"){if(!await r(e.path)){await R(e.path,JSON.stringify({hooks:{PostToolUse:[{matcher:"Edit|Write",hooks:[{type:"command",command:e.command}]}]}},null,2));return}let n=await Me(e.path,"utf-8"),s=JSON.parse(n);s.hooks||(s.hooks={}),s.hooks.PostToolUse||(s.hooks.PostToolUse=[]),s.hooks.PostToolUse.some(a=>a.hooks?.some(l=>l.command.includes("ultracite")))||(s.hooks.PostToolUse.push({matcher:"Edit|Write",hooks:[{type:"command",command:e.command}]}),await R(e.path,JSON.stringify(s,null,2)))}}}};f();import{spawnSync as Jt}from"child_process";import{mkdir as Lt,readFile as zt,writeFile as Ie}from"fs/promises";import Ht from"deepmerge";import{parse as Wt}from"jsonc-parser";var ce={"editor.defaultFormatter":"esbenp.prettier-vscode","[javascript]":{"editor.defaultFormatter":"biomejs.biome"},"[typescript]":{"editor.defaultFormatter":"biomejs.biome"},"[javascriptreact]":{"editor.defaultFormatter":"biomejs.biome"},"[typescriptreact]":{"editor.defaultFormatter":"biomejs.biome"},"[json]":{"editor.defaultFormatter":"biomejs.biome"},"[jsonc]":{"editor.defaultFormatter":"biomejs.biome"},"[css]":{"editor.defaultFormatter":"biomejs.biome"},"[graphql]":{"editor.defaultFormatter":"biomejs.biome"},"typescript.tsdk":"node_modules/typescript/lib","editor.formatOnSave":!0,"editor.formatOnPaste":!0,"emmet.showExpandedAbbreviation":"never","editor.codeActionsOnSave":{"source.fixAll.biome":"explicit","source.organizeImports.biome":"explicit"}};var G="./.vscode/settings.json",I={exists:()=>r(G),create:async()=>{await Lt(".vscode",{recursive:!0}),await Ie(G,JSON.stringify(ce,null,2))},update:async()=>{let t=await zt(G,"utf-8"),o=Wt(t)||{},n=Ht(o,ce);await Ie(G,JSON.stringify(n,null,2))},extension:()=>Jt("code --install-extension biomejs.biome",{stdio:"inherit",shell:!0})};f();import{mkdir as Bt,readFile as Gt,writeFile as _e}from"fs/promises";import qt from"deepmerge";import{parse as Vt}from"jsonc-parser";var le={formatter:"language_server",format_on_save:"on",languages:{JavaScript:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}},TypeScript:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}},JSX:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}},TSX:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}}},lsp:{"typescript-language-server":{settings:{typescript:{preferences:{includePackageJsonAutoImports:"on"}}}}}};var q="./.zed/settings.json",V={exists:()=>r(q),create:async()=>{await Bt(".zed",{recursive:!0}),await _e(q,JSON.stringify(le,null,2))},update:async()=>{let t=await Gt(q,"utf-8"),o=Vt(t)||{},n=qt(o,le);await _e(q,JSON.stringify(n,null,2))}};me();pe();ue();import{readFile as ko,writeFile as bo}from"fs/promises";import xo from"deepmerge";import{glob as vo}from"glob";import{parse as Co}from"jsonc-parser";var jo={compilerOptions:{strictNullChecks:!0}},Ye=async()=>{try{return await vo("**/tsconfig*.json",{ignore:["**/node_modules/**","**/dist/**","**/build/**","**/.next/**"],absolute:!1})}catch{return[]}},Po=async t=>{try{let e=await ko(t,"utf-8"),n=Co(e)||{},s=xo(n,jo);await bo(t,JSON.stringify(s,null,2))}catch(e){console.warn(`Failed to update ${t}:`,e)}},ye={exists:async()=>(await Ye()).length>0,update:async()=>{let t=await Ye();if(t.length===0){console.warn("No tsconfig.json files found in the project");return}await Promise.all(t.map(e=>Po(e)))}};f();var Ke=w.devDependencies["@biomejs/biome"],Xe=w.version,Eo=async(t,e=!0)=>{let o=u();o.start("Installing dependencies...");let n=[`ultracite@${Xe}`,`@biomejs/biome@${Ke}`];if(e)for(let s of n)await Ro(s,{packageManager:t,workspace:await g()});else await k({devDependencies:{"@biomejs/biome":Ke,ultracite:Xe}});o.stop("Dependencies installed.")},Fo=async()=>{let t=u();if(t.start("Checking for tsconfig.json files..."),await ye.exists()){t.message("Found tsconfig.json files, updating with strictNullChecks..."),await ye.update(),t.stop("tsconfig.json files updated.");return}t.stop("No tsconfig.json files found, skipping.")},$o=async()=>{let t=u();if(t.start("Checking for .vscode/settings.json..."),await I.exists()){t.message("settings.json found, updating..."),await I.update(),t.stop("settings.json updated.");return}t.message("settings.json not found, creating..."),await I.create(),t.message("settings.json created."),t.message("Installing Biome extension...");try{I.extension(),t.stop("settings.json created.")}catch(e){t.stop(`Failed to install Biome extension (${e}), but continuing...`)}},No=async()=>{let t=u();if(t.start("Checking for .zed/settings.json..."),await V.exists()){t.message("settings.json found, updating..."),await V.update(),t.stop("settings.json updated.");return}t.message("settings.json not found, creating..."),await V.create(),t.message("settings.json created. Install the Biome extension: https://biomejs.dev/reference/zed/")},Oo=async t=>{let e=u();if(e.start("Checking for Biome configuration..."),await B.exists()){e.message("Biome configuration found, updating..."),await B.update({frameworks:t}),e.stop("Biome configuration updated.");return}e.message("Biome configuration not found, creating..."),await B.create({frameworks:t}),e.stop("Biome configuration created.")},Do=async(t,e=!0)=>{let o=u();if(o.start("Initializing pre-commit hooks..."),o.message("Installing Husky..."),e?await x.install(t):await k({devDependencies:{husky:"latest"},scripts:{prepare:"husky"}}),o.message("Initializing Husky..."),x.init(t),await x.exists()){o.message("Pre-commit hook found, updating..."),await x.update(t),o.stop("Pre-commit hook updated.");return}o.message("Pre-commit hook not found, creating..."),await x.create(t),o.stop("Pre-commit hook created.")},To=async(t,e=!0)=>{let o=u();if(o.start("Initializing lefthook..."),o.message("Installing lefthook..."),e?await A.install(t):await k({devDependencies:{lefthook:"latest"}}),await A.exists()){o.message("lefthook.yml found, updating..."),await A.update(t),o.stop("lefthook.yml updated.");return}o.message("lefthook.yml not found, creating..."),await A.create(t),o.stop("lefthook.yml created.")},Mo=async(t,e=!0)=>{let o=u();if(o.start("Initializing lint-staged..."),o.message("Installing lint-staged..."),e?await E.install(t):await k({devDependencies:{"lint-staged":"latest"}}),await E.exists()){o.message("lint-staged found, updating..."),await E.update(t),o.stop("lint-staged updated.");return}o.message("lint-staged not found, creating..."),await E.create(t),o.stop("lint-staged created.")},Uo=async(t,e)=>{let o=u();o.start(`Checking for ${e}...`);let n=Oe(t);if(await n.exists()){o.message(`${e} found, updating...`),await n.update(),o.stop(`${e} updated.`);return}o.message(`${e} not found, creating...`),await n.create(),o.stop(`${e} created.`)},Io=async(t,e)=>{let o=u();o.start(`Checking for ${e} hooks...`);let n=Ue(t);if(await n.exists()){o.message(`${e} hooks found, updating...`),await n.update(),o.stop(`${e} hooks updated.`);return}o.message(`${e} hooks not found, creating...`),await n.create(),o.stop(`${e} hooks created.`)},_o=async t=>{let e=u();e.start("Removing Prettier dependencies and configuration...");try{let o=await ie.remove(t);o.packagesRemoved.length>0&&e.message(`Removed Prettier packages: ${o.packagesRemoved.join(", ")}`),o.filesRemoved.length>0&&e.message(`Removed config files: ${o.filesRemoved.join(", ")}`),o.vsCodeCleaned&&e.message("Cleaned VS Code settings"),e.stop("Prettier removed successfully.")}catch{e.stop("Failed to remove Prettier completely, but continuing...")}},Jo=async t=>{let e=u();e.start("Removing ESLint dependencies and configuration...");try{let o=await ne.remove(t);o.packagesRemoved.length>0&&e.message(`Removed ESLint packages: ${o.packagesRemoved.join(", ")}`),o.filesRemoved.length>0&&e.message(`Removed config files: ${o.filesRemoved.join(", ")}`),o.vsCodeCleaned&&e.message("Cleaned VS Code settings"),e.stop("ESLint removed successfully.")}catch{e.stop("Failed to remove ESLint completely, but continuing...")}},Qe=async t=>{So(be);try{let e=t??{},{pm:o}=e;if(!o){let d=await Ao(y.cwd());if(!d)throw new Error("No package manager specified or detected");if(d.warnings)for(let p of d.warnings)X.warn(p);X.info(`Detected lockfile, using ${d.name}`),o=d.name}let n=e.migrate?.includes("prettier"),s=e.migrate?.includes("eslint");if(n===void 0||s===void 0){let d=[];if(n===void 0&&await ie.hasPrettier()&&d.push({label:"Remove Prettier (dependencies, config files, VS Code settings)",value:"prettier"}),s===void 0&&await ne.hasEsLint()&&d.push({label:"Remove ESLint (dependencies, config files, VS Code settings)",value:"eslint"}),d.length>0){let p=await N({message:"Remove existing formatters/linters (recommended for clean migration)?",options:d,required:!1});$(p)&&(F("Operation cancelled."),y.exit(0)),n===void 0&&(n=p.includes("prettier")),s===void 0&&(s=p.includes("eslint"))}}let i=e.frameworks;if(i===void 0)if(e.pm||e.editors||e.agents||e.hooks||e.integrations!==void 0||e.migrate!==void 0)i=[];else{let p=await N({message:"Which frameworks are you using (optional)?",options:[{label:"React",value:"react"},{label:"Next.js",value:"next"},{label:"Solid",value:"solid"},{label:"Vue",value:"vue"},{label:"Svelte",value:"svelte"},{label:"Qwik",value:"qwik"},{label:"Angular",value:"angular"},{label:"Remix / TanStack Router / React Router",value:"remix"},{label:"Astro",value:"astro"}],required:!1});$(p)&&(F("Operation cancelled."),y.exit(0)),i=p}let a=e.editors;if(!a){let d=await N({message:"Which editors do you want to configure (recommended)?",options:[{label:"VSCode / Cursor / Windsurf",value:"vscode"},{label:"Zed",value:"zed"}],required:!1});$(d)&&(F("Operation cancelled."),y.exit(0)),a=d}let l=e.agents,m=e.hooks,P={"vscode-copilot":"GitHub Copilot (VSCode)",cursor:"Cursor",windsurf:"Windsurf",zed:"Zed",claude:"Claude Code",codex:"OpenAI Codex / Jules / OpenCode",kiro:"Kiro IDE",cline:"Cline",amp:"AMP",aider:"Aider","firebase-studio":"Firebase Studio","open-hands":"Open Hands","gemini-cli":"Gemini CLI",junie:"Junie",augmentcode:"Augment Code","kilo-code":"Kilo Code",goose:"Codename Goose","roo-code":"Roo Code",warp:"Warp"};if(!l){let d=await N({message:"Which agents do you want to enable (optional)?",options:Object.entries(P).map(([p,Q])=>({value:p,label:Q})),required:!1});$(d)&&(F("Operation cancelled."),y.exit(0)),l=d}let O={cursor:"Cursor",claude:"Claude Code"};if(!m){let d=await N({message:"Which agent hooks do you want to enable (optional)?",options:Object.entries(O).map(([p,Q])=>({value:p,label:Q})),required:!1});$(d)&&(F("Operation cancelled."),y.exit(0)),m=d}let S=e.integrations;if(S===void 0)if(e.pm||e.editors||e.agents||e.hooks||e.migrate!==void 0)S=[];else{let p=await N({message:"Would you like any of the following (optional)?",options:[{label:"Husky pre-commit hook",value:"husky"},{label:"Lefthook pre-commit hook",value:"lefthook"},{label:"Lint-staged",value:"lint-staged"}],required:!1});$(p)&&(F("Operation cancelled."),y.exit(0)),S=p}n&&await _o(o),s&&await Jo(o),await Eo(o,!e.skipInstall),await Fo(),await Oo(i),a?.includes("vscode")&&await $o(),a?.includes("zed")&&await No();for(let d of l??[])await Uo(d,P[d]);for(let d of m??[])await Io(d,O[d]);S?.includes("husky")&&await Do(o,!e.skipInstall),S?.includes("lefthook")&&await To(o,!e.skipInstall),S?.includes("lint-staged")&&await Mo(o,!e.skipInstall),X.success("Successfully initialized Ultracite configuration!")}catch(e){let o=e instanceof Error?e.message:"Unknown error";X.error(`Failed to initialize Ultracite configuration: ${o}`),y.exit(1)}};var j=Lo.meta().create(),Ho=j.router({init:j.procedure.meta({description:"Initialize Ultracite in the current directory"}).input(c.object({pm:c.enum(b.packageManagers).optional().describe("Package manager to use"),editors:c.array(c.enum(b.editorConfigs)).optional().describe("Editors to configure"),agents:c.array(c.enum(b.agents)).optional().describe("Agents to enable"),frameworks:c.array(c.enum(b.frameworks)).optional().describe("Frameworks being used"),integrations:c.array(c.enum(b.integrations)).optional().describe("Additional integrations to enable"),migrate:c.array(c.enum(b.migrations)).optional().describe("Migration tools to remove (e.g., eslint, prettier). Removes dependencies, config files, and editor settings."),skipInstall:c.boolean().default(!1).describe("Skip installing dependencies")})).mutation(async({input:t})=>{await Qe(t)}),check:j.procedure.meta({description:"Run Biome linter without fixing files"}).input(c.tuple([c.array(c.string()).optional().default([]).describe("specific files to lint"),c.object({"diagnostic-level":c.enum(["info","warn","error"]).optional().describe("level of diagnostics to show. In order, from the lowest to the most important: info, warn, error.")})]).optional()).query(({input:t})=>{se(t)}),fix:j.procedure.meta({description:"Run Biome linter and fixes files"}).input(c.tuple([c.array(c.string()).optional().default([]).describe("specific files to format"),c.object({unsafe:c.boolean().optional().describe("apply unsafe fixes")})])).mutation(({input:t})=>{let[e,o]=t;ae(e,{unsafe:o.unsafe})}),doctor:j.procedure.meta({description:"Verify your Ultracite setup and check for issues"}).query(async()=>{await Ee()}),lint:j.procedure.meta({description:"\u26A0\uFE0F DEPRECATED: Use 'check' instead - Run Biome linter without fixing files"}).input(c.array(c.string()).optional().default([]).describe("specific files to lint")).query(({input:t})=>{console.warn("\u26A0\uFE0F  Warning: 'lint' command is deprecated. Please use 'check' instead."),se([t,{}])}),format:j.procedure.meta({description:"\u26A0\uFE0F DEPRECATED: Use 'fix' instead - Run Biome linter and fixes files"}).input(c.tuple([c.array(c.string()).optional().default([]).describe("specific files to format"),c.object({unsafe:c.boolean().optional().describe("apply unsafe fixes")})])).mutation(({input:t})=>{let[e,o]=t;console.warn("\u26A0\uFE0F  Warning: 'format' command is deprecated. Please use 'fix' instead."),ae(e,{unsafe:o.unsafe})})}),Wo=zo({router:Ho,name:w.name,version:w.version,description:w.description});process.env.TEST||Wo.run();export{Ho as router};
